/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package it.unimi.dsi.webgraph.examples;

import it.unimi.dsi.fastutil.objects.ObjectArrayList;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

/**
 *
 * @author SCARS Lapi
 */
public class TypedEdgeGraph {
    /* This method takes in a String parameter which is the basename(filename wihout extension) of a file supposed to contain
     * information about the links in the way ot was given in PageLinks.txt and converst these links into tab separated triplets
     * first one of which is the source id, the second one being destination id and the 3rd one being the label which represents 
     * the type of the edge.
     * 
     */
    
    
    public static String reduce(String basename)throws Exception{
        FileInputStream fstream = new FileInputStream(basename+".txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        String links_file = "links_"+basename;
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(links_file+".txt"), false));
        
        String line;
        int source=0;
        int destination=0;
        int count=0;
        int label=0;
        
        while((line=br.readLine())!=null){
            String words[] = line.split("\t");
            if (words.length==5){
                source = Integer.parseInt(words[1]);
                destination = Integer.parseInt(words[3]);
                label = Integer.parseInt(words[4]);
            }
            else if(words.length==3){
                destination = Integer.parseInt(words[1]);
                label = Integer.parseInt(words[2]);
            }
            bw.write(source+"\t"+destination+"\t"+label);
            bw.newLine();
            bw.flush();
            count++;
            if(count%10000000==0)
                System.out.println("Crossed "+count);
        }
        bw.close();
        return links_file;
    }
    
/*
     * This method scans through the text file generated by the method "reduce" and finds the ids from the source nodes, and 
     * writes them in a text file. The idea is to create a mapping between the original page-ids (which range between 12 and 3 crores)
     *  but are around 37 lakhs in number, and natural numbers between 1-37 lakhs. 
     * 
     * This assumes that the source ids appear in an increasing order the name od the file contains the number of ids found 
     * only considering the source ids.
     */
    
    public static String write_ids(String links_file)throws Exception{
        FileInputStream fstream = new FileInputStream(links_file+".txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        String mapping_file = "ids_combined";
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(mapping_file+".txt"), false));
        
        String line;
        int source=0;
        int curr=-1;
        int count=0;
        while((line=br.readLine())!=null){
            String words[] = line.split("\t");
            source = Integer.parseInt(words[0]);
            if (source==curr)
                continue;
            else if(source < curr)
                System.out.println("Input not sorted as expected");
                
            bw.write(Integer.toString(source));
            curr = source;
            bw.newLine();
            bw.flush();
            count++;
            if(count%10000000==0)
                System.out.println("Crossed "+count);
        }
        
        bw.close();
        File f = new File(mapping_file+".txt");
        String map_file = mapping_file+"_"+Integer.toString(count);
        f.renameTo(new File(map_file+".txt"));
        return map_file;
    }
    
    /* This reads from a text file in which the page ids are stored in an increasing order, and loads this data in to a 
     * 37 * 100000 2-d array.
     * 
     * 
     */
    
    public static int[][] load_mapping(String mapping_file) throws Exception{
        int arraylength = 100000;
        int x = mapping_file.lastIndexOf('_');
        //int y = mapping_file.lastIndexOf('.');
        int totalcount = Integer.parseInt(mapping_file.substring(x+1));
        int numarray = (totalcount/arraylength)+1;
        System.out.println("number of arrays is "+numarray+" because totalcount is "+totalcount);
        int mapping[][] = new int[numarray][arraylength];
        FileInputStream fstream = new FileInputStream(mapping_file+".txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        String line;
        int i=0,a=0,b=0,j=0;
        //i=0;
        while((line=br.readLine())!=null){
            a = i/arraylength;
            b = i%arraylength;
            try{
                mapping[a][b] = Integer.parseInt(line);
            }
            catch(Exception E){
                System.out.println("check entry number "+i);
            }
            i++;
            if(a==numarray-1)
                j++;
        }
        //System.out.println("The last array is this long "+j);
        if(i<(numarray-1)*arraylength)
            System.out.println("Some problem because the number of ids is less than expected minimum bar");
        mapping[numarray-1] = Arrays.copyOf(mapping[numarray-1], j);
        return mapping;
    }
    
    public static int[][] load_mapping_mod() throws Exception{
        int mapping[][] = new int[37][100000];
        FileInputStream fstream = new FileInputStream("page_ids2.txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        String line;
        int i,a,b,j=0;
        i=0;
        while((line=br.readLine())!=null){
            a = i/100000;
            b = i%100000;
            try{
            mapping[a][b] = Integer.parseInt(line);
            }
            catch(Exception E){
                System.out.println("check entry number "+i);
            }
            i++;
            if(a==36)
                j++;
        }
        //System.out.println("The last array is this long "+j);
        mapping[36] = Arrays.copyOf(mapping[36], j);
        return mapping;
    }
    
    
    
    /*
     * This methods looks at the destination ids and checks if any such page ids exist which were not listed in the
     * source ids, and accordingly updates the mapping after sorting the changed ordering iteratively, considering 
     * 1000 missing ids at a time, modifying the mapping accordingly and now looking for the ids still missing.
     * 
     */
    public static String update_missing(String links_file, String mapping_file)throws Exception{
        int mapping[][] = load_mapping(mapping_file);
        int missing[] = new int[1000];
        mapping = modify_mapping(mapping,missing,0);
        //int special_mapping = Arrays.copyOf(mapping[36], newLength)
        System.out.println("Loaded the mapping successfully");
        FileInputStream fstream = new FileInputStream(links_file+".txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        String mapping_final = "final"+mapping_file;
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File(mapping_final+".txt"), false));
        
        String line;
        int destination_id;
        int i,j=0,count = 0,missingcount=0;
        //int missing[] = new int[1000];
        while((line=br.readLine())!=null){
            String words[] = line.split("\t");
            destination_id = Integer.parseInt(words[1]);
            i = find_array(destination_id,mapping);
            if(i>=0)
                j =Arrays.binarySearch(mapping[i],destination_id);
            else
                j=-1;
            if(j<0){
                //System.out.println(+destination_id+" not present in mapping");
                //bw.write(Integer.toString(destination_id));
                //bw.newLine();
                //bw.flush();
                missing[missingcount] = destination_id;
                missingcount++;
            }
            count++;
            if(count%1000000==0)
                System.out.println("The count is "+count);
            if(missingcount==1000){
                //System.out.println("Written down another 1000 missing entries");
                //sort_map();
                mapping = modify_mapping(mapping, missing, missingcount);
                //System.out.println("Modified the mapping");
                missingcount =0;
                missing = new int[1000];
            }
        }
        mapping = modify_mapping (mapping, missing, missingcount);
        int totalsize = (mapping.length-1)*mapping[0].length+mapping[mapping.length-1].length;
        for(int k=0;k<totalsize;k++){
            bw.write(Integer.toString(mapping[k/(mapping[0].length)][k%(mapping[0].length)]));
            bw.newLine();
            bw.flush();
        }
        bw.close();
        return mapping_final;
    }
    
    
    /* This modifies the mapping so as to accomodate the missing page ids.
     * 
     * mapping is the original mapping
     * missing is the array containing the missing ids 
     * missingcount is the number of missing ids, found
     */
    public static int[][] modify_mapping(int [][] mapping,int[] missing,int missingcount){
        int len = 0,j=0,a,b;
        int total = (mapping.length-1)*mapping[0].length +mapping[mapping.length-1].length;
        int array[] = new int[total+missingcount];
        int arraylength = mapping[0].length;
        //System.out.println("The arraylength is "+arraylength);
        while(len<total){
            a = len/arraylength;
            b = len%arraylength;
            array[len] = mapping[a][b];
            //if(len==210468)
            //    System.out.println("The 210468th element is "+mapping[a][b]+" when a and b are "+a+" and "+b);
            len++;
        }
        //array = Arrays.copyOf(array, len);
        for(; len<missingcount+total;len++){
            array[len] = missing[len-total];
        }
        mapping = new int[len/(arraylength)+1][arraylength];
        //System.out.println("The last element of array is "+array[array.length-1]);
        int zerocount =0;
        //int zeroplace = 0;
        for(int i=0;i<len;i++){
            if(array[i]==0){
                zerocount++;
                System.out.println("Zero found at "+i);
            }
        }
        //System.out.println("The number of zeros found is "+zerocount);
        Arrays.sort(array);
        //System.out.println("Just sorted the array, now writing back to mapping");
        int curr=-1;
        int count=0;
        //System.out.println("");
        for(int i=0;i<len;i++){
            if(curr ==array[i]){
                //System.out.println("Continuing because "+curr+" is same as "+i+"th element");
                continue;
            }
            if(count%100000==0)
                System.out.println("Written "+ count+" entries");
            curr = array[i];
            try{
                mapping[count/(arraylength)][count%(arraylength)] = array[i];
            }
            catch(Exception E){
                System.out.println("a= "+(count/arraylength)+" while i is "+i+"because count is "+count);
            }
            if((count/arraylength)==mapping.length-1)
                j++;
            count++;
        }
        //System.out.println("The last array is this long "+j);
        mapping[mapping.length-1] = Arrays.copyOf(mapping[mapping.length-1], j);
        return mapping;
    }
    /* This runs a binary search for finding out the array in which the dest_id might be present
     * 
     * 
     * 
     */
    public static int find_array(int dest_id, int[][] mapping){
        int low=0, hi = mapping.length-1,mid;
        //System.out.println("length of mapping is "+hi);
        //int size_array = mapping[0].length-1;
        int iter=0;
        if (dest_id<mapping[0][0])
            return -1;
        while(hi>low){
            mid = (hi+low)/2;
            //System.out.println("mid is "+mid);
            int size_array = mapping[mid].length-1;
            if(mid== hi)
                return hi;
            if(dest_id>=mapping[mid][0] && dest_id<=mapping[mid][size_array])
                return mid;
            if(dest_id<mapping[mid][0])
                hi = mid;
            else if(dest_id>mapping[mid][size_array])
                low = mid+1;
            iter++;
            if(iter>15){
                System.out.print("Stuck in loop for "+dest_id);
                return 0;
            }
                
        }
        return low;
    }
    
    /* This method taken takes in an n*2 array, where n is the number of links in the original file.
     * for a particular source and writes the arcs accordingly. The first column contains the destination ids and 
     * the second one contains the corresponding labels. Destnation having mulitple arcs from the same source having same labels
     * are counted as one instance of that label arc, and those having different labels are combined using a binary string of length
     * 20. The nth bit signifies whether one of the 20 different types of arcs exists between this source and destination. Further,
     * this binary representation is converted to an integer for the purpose of making the graph.
     * 
     * 
     * 
     */
    
    public static void write_arcs(int source, int[][] currentarray, BufferedWriter bw, int currcount) throws Exception{
        int currdest=-1;
        boolean labelarray[] = new boolean[20];
        Arrays.fill(labelarray,false);
        int label;
        int temp;
        //int labelcount=0;
        //int duplicates=0;
        //BufferedWriter bws = new BufferedWriter(new FileWriter(new File("pseudo_arcs.txt"), true));
        for (int i=0;i<currcount;i++){
            //System.out.println(Integer.toString(source)+"\t"+Integer.toString(currentarray[i][0])+"\t"+Integer.toString(currentarray[i][1]));
            if(currdest!=currentarray[i][0]){
                //label = (int)Math.pow(10,8)+labelarray[0]*(int)Math.pow(10, 6)+labelarray[1]*(int)Math.pow(10, 4)+labelarray[2]*(int)Math.pow(10, 2)+labelarray[3];
                String S = "00000000000000000000";
                for(int j=0;j<20;j++){
                    if (labelarray[j]==true)
                        S = S.substring(0, j)+Character.toString((char)49)+S.substring(j+1);
                }
                label = Integer.parseInt(S,2);
                if(i!=0){
                    if (source==currdest){
                        System.out.println("Still same");
                        continue;
                    }
                        
                    bw.write(Integer.toString(source)+"\t"+Integer.toString(currdest)+"\t"+Integer.toString(label));
                    bw.newLine();
                    bw.flush();
                }
                currdest = currentarray[i][0];
                labelarray = new boolean[20];
                Arrays.fill(labelarray,false);
                temp = currentarray[i][1];
                labelarray[temp] = true;
            }
            else if (currdest==currentarray[i][0]){
                //duplicates++;
                temp = currentarray[i][1];
                    
                labelarray[temp] = true;
                //labelcount++;
                
            }
        }
        //if(duplicates>0)
        //    System.out.println(duplicates+" duplicates removed");
    }
    
    /* This converts the page ids in each link to the mapped value between 1-37 lakh as given by the created mapping, and then
     * rewritess the triplets in a file named arcs_page.txt
     * 
     * 
     */
    
    
    
    public static void links_to_arcs(String links_file, String mapping_final)throws Exception{
        int mapping[][] = load_mapping(mapping_final);
        FileInputStream fstream = new FileInputStream(links_file+".txt");
        DataInputStream in = new DataInputStream(fstream);
        
        BufferedReader br = new BufferedReader( new InputStreamReader( in ) );
        BufferedWriter bw = new BufferedWriter(new FileWriter(new File("arcs_page.txt"), false));
        
        String line;
        int source_id,destination_id,source,destination,label;
        int i,j=0,count = 0;
        int curr_id = -1;
        int curr = -1;
        int max_outlinks = 15000;
        int currentarray[][] = new int[max_outlinks][2];
        int currcount=0;
        while((line=br.readLine())!=null){
            String words[] = line.split("\t");
            source_id = Integer.parseInt(words[0]);
            if (curr_id == source_id){
                source = curr;
                destination_id = Integer.parseInt(words[1]);
                i = find_array(destination_id,mapping);
                j =Arrays.binarySearch(mapping[i],destination_id);
                if(j<0)
                    System.out.println("Still there are missing ids like "+destination_id);
                destination = i*100000+j;
                if (destination==source){
                    //System.out.println("Same source and destination");
                    count++;
                    continue;
                }
                if (currcount==max_outlinks){
                        System.out.println("More than 15000 outlinks at "+count);
                        continue;
                }
                currentarray[currcount][0] = destination;
                currentarray[currcount][1] = Integer.parseInt(words[2]);
                currcount++;
            }
            else{
                
                if(currcount>0){
                    currentarray = Arrays.copyOf(currentarray, currcount);
                    Arrays.sort( currentarray, new Comparator<int[]>() {
			public int compare( int[] p, int[] q ) {
				final int t =  p[ 0 ] - q[ 0 ]; // Compare by source
				if ( t != 0 ) return t;
				return p[ 1 ] - q[ 1 ]; // Compare by destination
			}
		} );
                
                write_arcs(curr, currentarray, bw, currcount);
                }
                currentarray = new int[max_outlinks][2];
                currcount = 0;
                i = find_array(source_id,mapping);
                j = Arrays.binarySearch(mapping[i],source_id);
                if(j<0)
                    System.out.println("Still there are missing ids like "+source_id);
                source = i*100000+j;
                curr_id = source_id;
                curr = source;
                destination_id = Integer.parseInt(words[1]);
                i = find_array(destination_id,mapping);
                j =Arrays.binarySearch(mapping[i],destination_id);
                if(j<0)
                    System.out.println("Still there are missing ids like "+destination_id);
                destination = i*100000+j;
                if (destination==source){
                    //System.out.println("Same source and destination at "+count);
                
                }
                currentarray[currcount][0] = destination;
                currentarray[currcount][1] = Integer.parseInt(words[2]);
                currcount++;
            }
            
            //bw.write(Integer.toString(source)+"\t"+Integer.toString(destination)+"\t"+words[2]);
            count++;
            if(count%5000000==0)
                System.out.println("The count is "+count);
                //return;
        }
        bw.close();
    }
   /* This main method shows how to convert a given Pagelinks file into file haviing triplets which can be converted directly
     * into graphfiles using the implementation given in RelGrap. 
     * 
     * 
     */
    
    public static void main(String args[]) throws Exception{
        String links_file = reduce("PageLinks_combined");
        String mapping_file = write_ids(links_file);
        System.out.println("ids written down and name of mapping file is "+mapping_file);
        String mapping_final = update_missing(links_file, mapping_file);
        System.out.println("missing ids found and updated and name of the file returned is "+mapping_final);
        links_to_arcs(links_file,mapping_final);
    }
}